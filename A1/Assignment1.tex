\documentclass{article}
\usepackage{fullpage}
\usepackage[normalem]{ulem}
\usepackage{amstext}
\usepackage{amsmath}
\newcommand{\var}[1]{\mathit{#1}}
\setlength{\parskip}{6pt}

\begin{document}

\noindent
University of Toronto\\
{\sc csc}343, Fall 2017\\[10pt]
{\LARGE\bf Assignment 1: James Leja 1002527571 Chris Stalzer - need Chris's student \#} \\[10pt]

\noindent
Unary operators on relations:
\begin{itemize}
\item $\Pi_{x, y, z} (R)$
\item $\sigma_{condition} (R) $
\item $\rho_{New} (R) $
\item $\rho_{New(a, b, c)} (R) $
\end{itemize}
Binary operators on relations:
\begin{itemize}
\item $R \times S$
\item $R \bowtie S$
\item $R \bowtie_{condition} S$
\item $R \cup S$
\item $R \cap S$
\item $R - S$
\end{itemize}
Logical operators:
\begin{itemize}
\item $\vee$
\item $\wedge$
\item $\neg$
\end{itemize}
Assignment:
\begin{itemize}
\item $New(a, b, c) := R$
\end{itemize}
Stacked subscripts:
\begin{itemize}
\item
$\sigma_{\substack{this.something > that.something \wedge \\ this.otherthing \leq that.otherthing}}$
\end{itemize}

\noindent
Below is the text of the assignment questions; we suggest you include it in your solution.
We have also included a nonsense example of how a query might look in LaTeX.  
We used \verb|\var| in a couple of places to show what that looks like.  
If you leave it out, most of the time the algebra looks okay, but certain words,
{\it e.g.}, ``Offer" look horrific without it.

The characters ``\verb|\\|" create a line break and ``[5pt]" puts in 
five points of extra vertical space.  The algebra is easier to read with extra
vertical space.
We chose ``--" to indicate comments, and added less vertical space between comments
and the algebra they pertain to than between steps in the algebra.
This helps the comments visually stick to the algebra.


%----------------------------------------------------------------------------------------------------------------------
\section*{Part 1: Queries}

\begin{enumerate}

\item   % ----------
Find all the users who have never sent a message, but who have been sent at least one message. The message may have been sent to the user or to a group that the user belongs to. Report each user id. \\

{\large %This increase in font size makes the subscripts much more readable.
--  Messages that have been sent. \\ [5pt]
$
hasSent(\var{mID}, \var{uID}, \var{status}) :=  
	\sigma_{status = 'sent'} 
	Status \\[10pt]
$
-- uID of users who have received a message. \\[5pt]
$
hasReceived(\var{uID}) := 
	\Pi_{\var{uID}} 
	(Status - \var{hasSent}) 
	\\[10pt]
$
-- uID of users who have never sent a message. \\[5pt]
$
neverSent(\var{uID}) := 
	\Pi_{\var{uID}} User - \Pi_\var{uID}\var{hasSent} 
	\\[10pt]
$
$
Q1(\var{uID}) :=
	neverSent \cap hasReceived
$\\\\ % skips two lines...not sure how much we want to separate questions

} % End of font size increase.


\item   % ----------
Net neutrality is dead, so EVL ISP wants to slow the service of poor users (users who do not use the app enough). To do this, find the users (and return their uid) who sent two or fewer messages in 2017.\\\\
{\large
% Started indenting comments...might be cleaner.
\hspace*{1cm} -- Get all the messages that were sent in 2017 \\ [5pt]
$
2017Msgs(\var{mid}, \var{from}, \var{to}, \var{content}, \var{time}) :=
	\sigma_{time.year = 2017} Message
$\\

\hspace*{1cm} -- Get all the uIDs of the users who sent 3 or more messages in 2017. \\ [5pt]
% The substack below allows you to make multiple lines within one sigma. 
$
3orMore2017(\var{uID}) := \\ [5pt]
	\hspace*{1cm}  % This command creates an indentation
	\Pi_{M1.\var{uID}}( 
	\sigma_{\substack{ 
		M1.\var{from} = M2.\var{from} \\ 
		\wedge M1.\var{from} = M3.\var{from} \\
		\wedge M1.\var{mid} \neq M2.\var{mid} \\
		\wedge M2.\var{mid} \neq M3.\var{mid} \\
		\wedge M1.\var{mid} \neq M3.\var{mid} }}
	[ (\rho_{M1}2017Msgs) \times (\rho_{M2}2017Msgs) \times (\rho_{M3}2017Msgs )] \\[5pt]
$

$
Q2(uID) := \Pi_{\var{uID}} User - 3orMore2017
$
}
\item   % ----------	
Find the largest group. Report the group id. If there is a tie, report them all. \\\\ {\large
Cannot be expressed. \\
}

\item   % ---------- 
Find privacy fanatics, that is, any user who has all her privacy settings set to none and who has never sent a message to another user who has privacy settings different than her own (meaning different than all none). Note that a private user (settings are all none) who has never sent a message would be considered a privacy fanatic. Return the user’s uid and name.

{\large
\hspace*{1cm} -- Get the uIDs of the users with all their privacy settings set to none. \\ [5pt]
$
PrivUsers(\var{uID}) := 
	\Pi_{\var{uID}}
	(\sigma_{lastSeen = "none" \\
			\wedge profilePhoto = "none" \\
			\wedge profile = "none"} Privacy)
$ \\\\
\hspace*{1cm} -- Get the uIDs of the "non-private" users. \\ [5pt]
$
NonPrivUsers(\var{uID}) :=
	\Pi_{\var{uID}} Privacy - PrivateUsers
$ \\\\
\hspace*{1cm} -- Get messages sent from private to non-private users.	 \\ [5pt]
$
PrivtoNonPriv(\var{uID}) :=
	\Pi_{\var{PrivateUsers.uID}}
	(\sigma_{\substack{Message.from = PrivUsers.uID \\
		 \wedge Message.to = NonPrivUsers.uID}}
		(PrivUsers \times NonPrivUsers \times Message))	
$ \\	\\
\hspace*{1cm} -- get the uIDs of the private users who only send to other privates. \\ [5pt]
$
PrivtoPriv(\var{uID}) :=
	PrivateUsers = PrivtoNonPriv
$ \\\\
$
Q4(\var{uID}, name) :=
	\Pi_{\var{uID}, \var{name}} (User \bowtie PrivtoPriv)
$


}

\item   % ----------
Consider only users whose privacy settings state that everyone may see their lastSeen time (lastSeen = everyone). Among such users, report the uid, name and lastSeen of the user(s) whose lastSeen time is the most recent. Since times are ordered, the most recent time is the largest time value. If there are ties, report all users. These users have the most recent public lastSeen time.
{\large
\hspace*{1cm} -- Get the uid's of all users who's allow everyone to see their lastSeen time. \\ [5pt]
$
LastSeenAll(\var{uID}) :=
	\Pi_{\var{\var{uID}}}
	(\sigma_{lastSeen = "Everyone"} Privacy)
$ \\\\
\hspace*{1cm} -- Get the uID's and times of the users with open privacy settings. \\ [5pt]
$
OpenUser(uID, lastSeen) := 
	\Pi_{user.uID, user.lastSeen}
	(User \bowtie_{user.uID = LastSeenAll.uID})
$\\\\
\hspace*{1cm} -- Get all but the most recent lastSeen times of open users. \\ [5pt]
$
NotRecent(\var{uID}) := \Pi_{\var{OU1.uID}}
	\sigma_{OU1.\var{lastSeen} < OU2.\var{lastSeen}}
	(\rho_{OU1}OpenUser \times \rho_{OU2}OpenUser)
$\\\\
\hspace*{1cm} -- Get uID's of the most recent open users
$
MostRecent(\var{uID}) := LastSeenAll - NotRecent
$\\\\
\hspace*{1cm} -- Connect the most recent uID's with the User relation to get their names and lastSeen times. \\ [5pt]
$
Q5(\var{uID}, \var{name}, \var{lastSeen}) := 
	\Pi_{\var{Uid}, \var{name}, \var{lastSeen}} 
	(User \bowtie_{user.\var{uID} = MostRecent.\var{uID}})
$\\\\
}

\item   % ----------
A user’s contact list can be sorted by the start time. Find users who send their first direct message to a contact in the same order as the contact list order. So if Sue is Pat’s oldest contact and Jo is the second oldest contact, then Pat’s first direct message to Sue happens before her first direct message to Jo and so on for all contacts. Include users with empty contact lists. Return user’s uid. \\ [5pt]
\large{
\hspace*{1cm} -- Get the all the messages that have been sent directly to a user. \\ [5pt]
$
Dmessage(\var{mID}, \var{from}, \var{to}, \var{time}) := \\
	\hspace*{1in}
	\Pi_{\substack{\var{Message.mID} \\
		\wedge \var{Message.from} \\
		\wedge \var{Message.to} \\
		\wedge \var{Message.time}}} 
	\sigma_{\var{Message.to} = \var{User.uID}}
	(Message \times \Pi_{\var{uID} User}) \\\\
$
\hspace*{1cm} -- Get the all but the earliest direct messages. \\ [5pt]
$
AllButEarliest := \\
	\hspace*{1in}
	\Pi_{\substack{\var{M1.mID} \\
		\wedge \var{M1.from} \\
		\wedge \var{M1.to} \\
		\wedge \var{M1.time}}} 
	(\sigma_{\substack{\var{M1.to} = \var{M2.to} \\
		\wedge \var{M1.from} = \var{M2.from} \\
		\wedge \var{M1.time} > \var{M2.time}}}
	(\rho_{\var{M1}} DMessage \times \rho_{\var{M2}} DMessage)) \\\\
$
\hspace*{1cm} -- Get the earliest direct messages. \\ [5pt] 
$
Earliest = Dmessage - AllButEarliest \\\\
$
\hspace*{1cm} -- Get the uIDs of the users whose earliest direct messages are not in the same order as their contact start time. \\ [5pt]
$
NotInOrder(\var{uID}) := \\ [5pt]
	\Pi_{\var{C1.uID}}
	(\sigma_{\substack{\var{C1.user} = \var{C2.user} \\
		\wedge \var{C1.user} = \var{E1.from} \\
		\wedge \var{C1.user} = \var{E2.from} \\
		\wedge \var{C1.contact} = \var{E1.to} \\
		\wedge \var{C1.contact} = \var{E2.to} \\
		\wedge \var{C1.contact} \neq \var{C2.contact} \\
		\wedge \var{C1.start} > \var{C2.start} \\
		\wedge \var{E1.time} < \var{E2.time}}}
		(\rho_{\var{C1}} Contact \times \rho_{\var{C2}} Contact
		\times \rho_{\var{E1}} Earliest \times \rho_{\var{E2}} Earliest)) \\ [5pt]
$
$
Q6(uID) := 
	\Pi_{\var{uID}} User - NotInOrder
$
}
\item   % ----------
Return all pairs of users with the same name. Return the two uids and the common name. Return
each pair only once. (For example, if user 1 and user 2 are both named 'Pat', then return either [1, 2,
'Pat'] or [2, 1, 'Pat'] but not both). \\ [5pt]
\large{
\hspace*{1cm} -- Get the uID's and name of each pair of users with the same name. \\ [5 pt]
$
Q7(uId, uId, Name) := \Pi_{\var{U1.uID}, \var{U2.uID}, \var{U1.name}}
	 \sigma_{\substack{{\var{U1.uID}}  <  \var{U2.uID} \\
	  \wedge \var{U1.name} = \var{U2.name}}} (\rho_{\var{U1}} User \times \rho_{U2}User) \\ [5pt]
$

}
\item   % ----------
Report the name and email of the user
who has gained the greatest number of new followers in 2017. 
If there is a tie, report them all.

\item   % ----------
For each user who has ever viewed any story, 
	report their id and the id of the first and of the last story they have seen.
If there is a tie for the first story seen, report both;
if there is a tie for the last story seen, report both.
This means that a user could have up to 4 rows in the resulting relation.

\item   % ----------
A comment is said to have either positive or negative sentiment
based on the presence of words such as ``like,'' ``love,'' ``dislike,'' and ``hate.'' 
A ``sentiment shift" in the comments on a post occurs at moment $m$ iff
all comments on that post before $m$ have positive sentiment, 
while all comments on that post after $m$ have negative sentiment ---
or the other way around, with comments shifting from negative to positive sentiment.

Find posts that have at least three comments and for which there has been a sentiment shift over time. 
For each post, report the user who owns it and,
for each comment on the post,
the commenter's id, 
the date of their comment and its sentiment.

You may assume there is a function, called {\it sentiment}
that can be applied to a comment's text and 
returns the sentiment of the comment as a string with the value ``positive" or ``negative".
For example,
you may refer to $sentiment(text)$ in the condition of a select operator.

\end{enumerate}



%----------------------------------------------------------------------------------------------------------------------
\section*{Part 2: Additional Integrity Constraints}


Express the following integrity constraints
with the notation $R = \emptyset$, where $R$ is an expression of relational algebra. 
You are welcome to define intermediate results with assignment
and then use them in an integrity constraint.

\begin{enumerate}

\item   % ----------
A comment on a post must occur after the date-time of the post itself.
(Remember that you can compare two date-time attributes with simple $<$,
$>=$ etc.)

\item %---------
Each user can have at most one current story.

\item %----------
Every post must include at least one picture or one video and so must every story.

\end{enumerate}

\end{document}


