\documentclass{article}
\usepackage{fullpage}
\usepackage[normalem]{ulem}
\usepackage{amstext}
\usepackage{amsmath}
\newcommand{\var}[1]{\mathit{#1}}
\setlength{\parskip}{6pt}

\begin{document}

\noindent
University of Toronto\\
{\sc csc}343, Fall 2017\\[10pt]
{\LARGE\bf Assignment 1: James Leja 1002527571 Chris Stalzer - need Chris's student \#} \\[10pt]

\noindent
Unary operators on relations:
\begin{itemize}
\item $\Pi_{x, y, z} (R)$
\item $\sigma_{condition} (R) $
\item $\rho_{New} (R) $
\item $\rho_{New(a, b, c)} (R) $
\end{itemize}
Binary operators on relations:
\begin{itemize}
\item $R \times S$
\item $R \bowtie S$
\item $R \bowtie_{condition} S$
\item $R \cup S$
\item $R \cap S$
\item $R - S$
\end{itemize}
Logical operators:
\begin{itemize}
\item $\vee$
\item $\wedge$
\item $\neg$
\end{itemize}
Assignment:
\begin{itemize}
\item $New(a, b, c) := R$
\end{itemize}
Stacked subscripts:
\begin{itemize}
\item
$\sigma_{\substack{this.something > that.something \wedge \\ this.otherthing \leq that.otherthing}}$
\end{itemize}

\noindent
Below is the text of the assignment questions; we suggest you include it in your solution.
We have also included a nonsense example of how a query might look in LaTeX.  
We used \verb|\var| in a couple of places to show what that looks like.  
If you leave it out, most of the time the algebra looks okay, but certain words,
{\it e.g.}, ``Offer" look horrific without it.

The characters ``\verb|\\|" create a line break and ``[5pt]" puts in 
five points of extra vertical space.  The algebra is easier to read with extra
vertical space.
We chose ``--" to indicate comments, and added less vertical space between comments
and the algebra they pertain to than between steps in the algebra.
This helps the comments visually stick to the algebra.


%----------------------------------------------------------------------------------------------------------------------
\section*{Part 1: Queries}

\begin{enumerate}

\item   % ----------
Find all the users who have never sent a message, but who have been sent at least one message. The message may have been sent to the user or to a group that the user belongs to. Report each user id. \\

{\large %This increase in font size makes the subscripts much more readable.
--  Messages that have been sent. \\ [5pt]
$
hasSent(\var{mID}, \var{uID}, \var{status}) :=  
	\sigma_{status = 'sent'} 
	Status \\[10pt]
$
-- uID of users who have received a message. \\[5pt]
$
hasReceived(\var{uID}) := 
	\Pi_{\var{uID}} 
	(Status - \var{hasSent}) 
	\\[10pt]
$
-- uID of users who have never sent a message. \\[5pt]
$
neverSent(\var{uID}) := 
	\Pi_{\var{uID}} User - \Pi_\var{uID}\var{hasSent} 
	\\[10pt]
$
$
Q1(\var{uID}) :=
	neverSent \cap hasReceived
$\\\\ % skips two lines...not sure how much we want to separate questions

} % End of font size increase.


\item   % ----------
Net neutrality is dead, so EVL ISP wants to slow the service of poor users (users who do not use the app enough). To do this, find the users (and return their uid) who sent two or fewer messages in 2017.\\\\
{\large
% Started indenting comments...might be cleaner.
\hspace*{1cm} -- Get all the messages that were sent in 2017 \\ [5pt]
$
2017Msgs(\var{mid}, \var{from}, \var{to}, \var{content}, \var{time}) :=
	\sigma_{time.year = 2017} Message
$\\

\hspace*{1cm} -- Get all the uIDs of the users who sent 3 or more messages in 2017. \\ [5pt]
% The substack below allows you to make multiple lines within one sigma. 
$
3orMore2017(\var{uID}) := \\ [5pt]
	\hspace*{1cm}  % This command creates an indentation
	\Pi_{M1.\var{uID}}( 
	\sigma_{\substack{ 
		M1.\var{from} = M2.\var{from} \\ 
		\wedge M1.\var{from} = M3.\var{from} \\
		\wedge M1.\var{mid} \neq M2.\var{mid} \\
		\wedge M2.\var{mid} \neq M3.\var{mid} \\
		\wedge M1.\var{mid} \neq M3.\var{mid} }}
	[ (\rho_{M1}2017Msgs) \times (\rho_{M2}2017Msgs) \times (\rho_{M3}2017Msgs )] \\[5pt]
$

$
Q2(uID) := \Pi_{\var{uID}} User - 3orMore2017
$
}
\item   % ----------	
Find the largest group. Report the group id. If there is a tie, report them all. \\\\ {\large
Cannot be expressed. \\
}

\item   % ---------- 
Find privacy fanatics, that is, any user who has all her privacy settings set to none and who has never sent a message to another user who has privacy settings different than her own (meaning different than all none). Note that a private user (settings are all none) who has never sent a message would be considered a privacy fanatic. Return the user’s uid and name.

{\large
\hspace*{1cm} -- Get the uIDs of the users with all their privacy settings set to none. \\ [5pt]
$
PrivUsers(\var{uID}) := 
	\Pi_{\var{uID}}
	(\sigma_{lastSeen = "none" \\
			\wedge profilePhoto = "none" \\
			\wedge profile = "none"} Privacy)
$ \\\\
\hspace*{1cm} -- Get the uIDs of the "non-private" users. \\ [5pt]
$
NonPrivUsers(\var{uID}) :=
	\Pi_{\var{uID}} Privacy - PrivateUsers
$ \\\\
\hspace*{1cm} -- Get messages sent from private to non-private users.	 \\ [5pt]
$
PrivtoNonPriv(\var{uID}) :=
	\Pi_{\var{PrivateUsers.uID}}
	(\sigma_{\substack{Message.from = PrivUsers.uID \\
		 \wedge Message.to = NonPrivUsers.uID}}
		(PrivUsers \times NonPrivUsers \times Message))	
$ \\	\\
\hspace*{1cm} -- get the uIDs of the private users who only send to other privates. \\ [5pt]
$
PrivtoPriv(\var{uID}) :=
	PrivateUsers = PrivtoNonPriv
$ \\\\
$
Q4(\var{uID}, name) :=
	\Pi_{\var{uID}, \var{name}} (User \bowtie PrivtoPriv)
$


}

\item   % ----------
Consider only users whose privacy settings state that everyone may see their lastSeen time (lastSeen = everyone). Among such users, report the uid, name and lastSeen of the user(s) whose lastSeen time is the most recent. Since times are ordered, the most recent time is the largest time value. If there are ties, report all users. These users have the most recent public lastSeen time.
{\large
\hspace*{1cm} -- Get the uid's of all users who's allow everyone to see their lastSeen time. \\ [5pt]
$
LastSeenAll(\var{uID}) :=
	\Pi_{\var{\var{uID}}}
	(\sigma_{lastSeen = "Everyone"} Privacy)
$ \\\\
\hspace*{1cm} -- Get the uID's and times of the users with open privacy settings. \\ [5pt]
$
OpenUser(uID, lastSeen) := 
	\Pi_{user.uID, user.lastSeen}
	(User \bowtie_{user.uID = LastSeenAll.uID})
$\\\\
\hspace*{1cm} -- Get all but the most recent lastSeen times of open users. \\ [5pt]
$
NotRecent(\var{uID}) := \Pi_{\var{OU1.uID}}
	\sigma_{OU1.\var{lastSeen} < OU2.\var{lastSeen}}
	(\rho_{OU1}OpenUser \times \rho_{OU2}OpenUser)
$\\\\
\hspace*{1cm} -- Get uID's of the most recent open users
$
MostRecent(\var{uID}) := LastSeenAll - NotRecent
$\\\\
\hspace*{1cm} -- Connect the most recent uID's with the User relation to get their names and lastSeen times. \\ [5pt]
$
Q5(\var{uID}, \var{name}, \var{lastSeen}) := 
	\Pi_{\var{Uid}, \var{name}, \var{lastSeen}} 
	(User \bowtie_{user.\var{uID} = MostRecent.\var{uID}})
$\\\\
}

\item   % ----------
A user’s contact list can be sorted by the start time. Find users who send their first direct message to a contact in the same order as the contact list order. So if Sue is Pat’s oldest contact and Jo is the second oldest contact, then Pat’s first direct message to Sue happens before her first direct message to Jo and so on for all contacts. Include users with empty contact lists. Return user’s uid. \\ [5pt]
\large{
\hspace*{1cm} -- Get the all the messages that have been sent directly to a user. \\ [5pt]
$
Dmessage(\var{mID}, \var{from}, \var{to}, \var{time}) := \\
	\hspace*{1in}
	\Pi_{\substack{\var{Message.mID} \\
		\wedge \var{Message.from} \\
		\wedge \var{Message.to} \\
		\wedge \var{Message.time}}} 
	\sigma_{\var{Message.to} = \var{User.uID}}
	(Message \times \Pi_{\var{uID} User}) \\\\
$
\hspace*{1cm} -- Get the all but the earliest direct messages. \\ [5pt]
$
AllButEarliest := \\
	\hspace*{1in}
	\Pi_{\substack{\var{M1.mID} \\
		\wedge \var{M1.from} \\
		\wedge \var{M1.to} \\
		\wedge \var{M1.time}}} 
	(\sigma_{\substack{\var{M1.to} = \var{M2.to} \\
		\wedge \var{M1.from} = \var{M2.from} \\
		\wedge \var{M1.time} > \var{M2.time}}}
	(\rho_{\var{M1}} DMessage \times \rho_{\var{M2}} DMessage)) \\\\
$
\hspace*{1cm} -- Get the earliest direct messages. \\ [5pt] 
$
Earliest = Dmessage - AllButEarliest \\\\
$
\hspace*{1cm} -- Get the uIDs of the users whose earliest direct messages are not in the same order as their contact start time. \\ [5pt]
$
NotInOrder(\var{uID}) := \\ [5pt]
	\Pi_{\var{C1.uID}}
	(\sigma_{\substack{\var{C1.user} = \var{C2.user} \\
		\wedge \var{C1.user} = \var{E1.from} \\
		\wedge \var{C1.user} = \var{E2.from} \\
		\wedge \var{C1.contact} = \var{E1.to} \\
		\wedge \var{C1.contact} = \var{E2.to} \\
		\wedge \var{C1.contact} \neq \var{C2.contact} \\
		\wedge \var{C1.start} > \var{C2.start} \\
		\wedge \var{E1.time} < \var{E2.time}}}
		(\rho_{\var{C1}} Contact \times \rho_{\var{C2}} Contact
		\times \rho_{\var{E1}} Earliest \times \rho_{\var{E2}} Earliest)) \\ [5pt]
$
$
Q6(uID) := 
	\Pi_{\var{uID}} User - NotInOrder
$
}
\item   % ----------
Return all pairs of users with the same name. Return the two uids and the common name. Return
each pair only once. (For example, if user 1 and user 2 are both named 'Pat', then return either [1, 2,
'Pat'] or [2, 1, 'Pat'] but not both). \\ [5pt]
\large{
\hspace*{1cm} -- Get the uID's and name of each pair of users with the same name. \\ [5 pt]
$
Q7(uId, uId, Name) := \Pi_{\var{U1.uID}, \var{U2.uID}, \var{U1.name}}
	 \sigma_{\substack{{\var{U1.uID}}  <  \var{U2.uID} \\
	  \wedge \var{U1.name} = \var{U2.name}}} (\rho_{\var{U1}} User \times \rho_{U2}User) \\ [5pt]
$

}
\item   % ----------
For each user and contact, report the time that the first direct message was sent from the user to the
contact and the time the last direct message was sent. Return the uid of the user (in an attribute
named user) and the contact (in an attribute named contact) and the first time (earliest) (in an
attribute named first) and last (most recent) time (in an attribute named last). If a user has not
sent any direct messages to a contact then include the user and contact with the value 0 for both the
first and last times. \\ [5pt]
\large{
\hspace*{1cm} -- Get all direct messages \\ [5pt]
$
dMessage(mID, from, to, content, time) := \Pi_{\var{mID}, \var{from}, \var{to}, \var{content}, \var{time}} \\
\sigma_{\var{Message.to} = \var{User.uID}} Message \times User \\ [5pt]
$
$
NoMessages(\var{uID }, \var{uID}, \var{0}, \var{0}) := \Pi_{\var{uID}, \var{contact}} \\
 Contact -  \Pi_{\var{to}, \var{from}} dMessage
$
$
AllButEarliest(mID, from, to, content, time) := \Pi_{\var{M1.mID}, \var{M1.from},\\
					\var{M1.content}, \var{M1.time}} \\
					\sigma_{\substack{ \var{M1.time} > \var{M2.time} \\
					\wedge M1.from = M2.from \\
					\wedge \var{M1.to} = \var{M2.to}}} \\
					\rho_{\var{M1}} dMessage \times \rho_{\var{M2}} dMessage
$
$
Earliest(mID, from, to, content, time) := dMessage - AllButEarliest
$
$
AllButLatest(mID, from, to, content, time) := \Pi_{\var{M1.mID}, \var{M1.from}, \\
					\var{M1.content},\var{M1.time}} \\
					\sigma_{\substack{ \var{M1.time} < \var{M2.time} \\
					\wedge \var{M1.from} = \var{M2.from} \\
					\wedge \var{M1.to} = \var{M2.to}}}
					\rho_{\var{M1}} dMessage \times \rho_{\var{M2}} dMessage
$
$
Latest(mID, from, to, content, time) := dMessage - AllButLatest
$
$
Earliest\&Latest(uID, uID, time, time) := \Pi_{\var{E.from}, \var{E.to}, \var{E.time}, \var{L.time}}\\
					\sigma_{\substack{E.from = L.from
					\wedge E.to = L.to}}
					\rho_{E}Earliest \times \rho_{L}Latest
$
$
Q8(User, Contact, First, Last) := Earliest\&Lastest \cap NoMessages  \\ [5pt]
$

}

\item   % ----------
A 'spammer' is a user who posts unwanted direct messages that are not read. A spammer must have
sent at least direct message (so this message will appear in the Status relation). Because users may not
be aware that someone is a spammer, they may read some of their initial messages. However, once they
decide a certain user is a spammer, the receivers stop reading all messages from the spammer. This
means that for a user who is sent a direct message from a spammer there are no delivered messages
with a time that is earlier than any read message from the spammer. Return the spammer's user id
and all their privacy settings (Privacy.lastSeen, Privacy.photo, Privacy.profile).
Do not consider groups for this question. Only consider direct messages sent from a user to another
single user (not to a group). \\ [5pt]
\large{
\hspace*{1cm} -- Get all direct messages. \\ [5pt]
$
dMessage(mID, from, to, content, time) := \Pi_{\var{mID}, \var{from}, \var{to}, \var{content}, \var{time}} \\
\sigma_{\var{Message.to} = \var{User.uID}} Message \times User \\ [5pt]
$
$dMessage\&Status() := dMessage \bowtie Status \\[5pt]
$
$
NotSpam(uID) := \Pi_{D1.from} \sigma_{\substack{D1.mID != D2.mID \\
																\wedge D1.from = D2.from \\
																\wedge D1.to = D2.to \\
																\wedge D1.time > D2.time \\
																\wedge D1.status = "Read \\
																\wedge D2.status = "Delivered"}}
																\rho_{D1} dMessage\&Status \times \\
																\rho_{D2} dMessage\&Status \\ [5pt]
$
$
Spammer(uID) := User - NotSpam\\ [5pt]
$
$
Q9(uID, lastSeen, Photo, Profile) := Spammer \bowtie Privacy \\ [5pt]													
$
}

\item   % ----------
A comment is said to have either positive or negative sentiment
based on the presence of words such as ``like,'' ``love,'' ``dislike,'' and ``hate.'' 
A ``sentiment shift" in the comments on a post occurs at moment $m$ iff
all comments on that post before $m$ have positive sentiment, 
while all comments on that post after $m$ have negative sentiment ---
or the other way around, with comments shifting from negative to positive sentiment.

Find posts that have at least three comments and for which there has been a sentiment shift over time. 
For each post, report the user who owns it and,
for each comment on the post,
the commenter's id, 
the date of their comment and its sentiment.

You may assume there is a function, called {\it sentiment}
that can be applied to a comment's text and 
returns the sentiment of the comment as a string with the value ``positive" or ``negative".
For example,
you may refer to $sentiment(text)$ in the condition of a select operator.

\end{enumerate}



%----------------------------------------------------------------------------------------------------------------------
\section*{Part 2: Additional Integrity Constraints}


Express the following integrity constraints
with the notation $R = \emptyset$, where $R$ is an expression of relational algebra. 
You are welcome to define intermediate results with assignment
and then use them in an integrity constraint.

\begin{enumerate}

\item   % ----------
A comment on a post must occur after the date-time of the post itself.
(Remember that you can compare two date-time attributes with simple $<$,
$>=$ etc.)

\item %---------
Each user can have at most one current story.

\item %----------
Every post must include at least one picture or one video and so must every story.

\end{enumerate}

\end{document}


